{"version":3,"file":"demo.js","mappings":"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","sources":["webpack://sms-href/./lib/detectors.js","webpack://sms-href/./lib/contants.js","webpack://sms-href/./lib/classes/sms-href-piapi.js","webpack://sms-href/./demo/src/index.js"],"sourcesContent":["/////////////////////\nconst UA = navigator.userAgent;\n/////////////////////\n/**\n * Checks if the user agent corresponds to an iOS device and returns its version.\n *\n * @returns {number} Returns the iOS version.\n *                   - `version` - If is iOS, and version is provided return major iOS version.\n *                   - `-1` - If is iOS, and version is not provided.\n *                   - `0` - Returns 0 if the user agent does not match iOS.\n * @example\n * // Returns 14 if the user agent matches \"CPU OS 14_0\"\n * const iOSVersion = isIOS();\n */\nexport const isIOS = () => {\n    let value;\n    // Check if the user agent matches the pattern of iOS devices\n    if (/CPU like.*AppleWebKit.*Mobile/i.test(UA)) {\n        // Return -1 if the user agent corresponds to a non-iOS device\n        return -1;\n    }\n    // Extract iOS version number from the user agent string\n    return isNaN((value = +UA.match(/CPU.*OS ([0-9]{1,5})/i)?.[1])) ? 0 : value;\n};\n/**\n * Checks if the user agent corresponds to an Android device and returns its version.\n *\n * @returns {number} Returns the Android version.\n *                   - `version` - If is Android, and version is provided return major Android version.\n *                   - `-1` - If is Android, and version is not provided.\n *                   - `0` - Returns 0 if the user agent does not match \"Android\".\n * @example\n * // Returns 10 if the user agent matches \"Android 10\"\n * const androidVersion = isAndroid();\n */\nexport const isAndroid = () => {\n    let value;\n    // Extract groups from the user agent string matching \"Android\" followed by version number\n    let groups = UA.match(/(Android) ([0-9]{1,5})?/i);\n    // If there are no groups or the first group is not present, return 0\n    if (!groups?.[1]) {\n        return 0;\n    }\n    // If the version number is present, convert it to a number, else return -1\n    return isNaN((value = +groups?.[2])) ? -1 : value;\n};\n/**\n * Checks if the device is an iPhone.\n *\n * @returns {boolean} True if the device is an iPhone, otherwise false.\n * @example\n * // Returns true if the device is an iPhone\n * const isDeviceIPhone = isIPhone();\n */\nexport const isIPhone = () => \n// Check if the device is iOS and not an iPod or iPad\n!!isIOS() && !isIPod() && !isIPad();\n/**\n * This is an alias for {@link isIPhone} function.\n *\n * Checks if the device is an iOS mobile (iPhone).\n */\nexport const isAppleMobile = isIPhone;\n/**\n * Checks if the device is an iPod.\n *\n * @returns {boolean} True if the device is an iPod, otherwise false.\n * @example\n * // Returns true if the device is an iPod\n * const isIPodDevice = isIPod();\n */\nexport const isIPod = () => \n// Check if the device is iOS and if the user agent contains \"ipod\"\n!!isIOS() && /ipod/i.test(UA);\n/**\n * Checks if the device is an iPad.\n *\n * @returns {boolean} True if the device is an iPad, otherwise false.\n * @example\n * // Returns true if the device is an iPad\n * const isIPadDevice = isIPad();\n */\nexport const isIPad = () => \n// Check if the device is iOS and if the user agent contains \"ipad\"\n!!isIOS() && /ipad/i.test(UA);\n/**\n * This is an alias for {@link isIPad} function.\n *\n * Checks if the device is an iOS tablet (iPad).\n */\nexport const isIosTablet = isIPad;\n/**\n * This is an alias for {@link isIPad} function.\n *\n * Checks if the device is an Apple tablet (iPad).\n */\nexport const isAppleTablet = isIPad;\n/**\n * Checks if the device is an Android mobile device.\n * @returns {boolean} True if the device is an Android mobile device, otherwise false.\n * @example\n * // Returns true if the device is an Android mobile device\n * const isAndroidMobileDevice = isAndroidMobile();\n */\nexport const isAndroidMobile = () => \n// Check if the device is Android and if the user agent contains \"Mobile\"\n!!isAndroid() && /Mobile/i.test(UA);\n/**\n * Checks if the device is an Android tablet.\n *\n * @returns {boolean} True if the device is an Android tablet, otherwise false.\n * @example\n * // Returns true if the device is an Android tablet\n * const isDeviceAndroidTablet = isAndroidTablet();\n */\nexport const isAndroidTablet = () => \n// Check if the device is Android and if the user agent does not contain \"Mobile\"\n!!isAndroid() && !isAndroidMobile();\n/**\n * Checks if the device is a tablet (either Android tablet or iPad).\n *\n * @returns {boolean} True if the device is a tablet, otherwise false.\n * @example\n * // Returns true if the device is a tablet\n * const isDeviceTablet = isTablet();\n */\nexport const isTablet = () => isIPad() || isAndroidTablet();\n/**\n * Checks if the device is a mobile device (either iPhone or Android mobile).\n *\n * @returns {boolean} True if the device is a mobile device, otherwise false.\n * @example\n * // Returns true if the device is a mobile device\n * const isDeviceMobile = isMobile();\n */\nexport const isMobile = () => isIPhone() || isAndroidMobile();\n/**\n * Checks if the user agent corresponds to a Facebook browser.\n *\n * @returns {boolean} True if the user agent indicates a Facebook browser, otherwise false.\n * @example\n * // Returns true if the user agent indicates a Facebook browser\n * const isFacebookBrowser = isFacebook();\n */\nexport const isFacebook = () => \n// Test if the user agent contains \"fban\" or \"fbav\"\n/fba[nv]/i.test(UA);\n/**\n * Checks if the user agent corresponds to Instagram.\n *\n * @returns {boolean} True if the user agent indicates Instagram, otherwise false.\n * @example\n * // Returns true if the user agent indicates Instagram\n * const isInstagram = isInstagram();\n */\nexport const isInstagram = () => \n// Test if the user agent contains \"instagram\" (case-insensitive)\n/instagram/i.test(UA);\n/**\n * Checks if the user agent string contains \"LinkedIn\".\n *\n * @returns {boolean} Returns true if the user agent string contains \"LinkedIn\", otherwise false.\n * @example\n * // Returns true if UA contains \"LinkedIn\"\n * const result = isLinkedin();\n *\n * @see https://explore.whatismybrowser.com/useragents/explore/software_name/linkedin-app/\n */\nexport const isLinkedin = () => \n// Test if the user agent contains \"LinkedIn\" (case-insensitive)\n/linkedin/i.test(UA);\n","/**\n * This function is not available in Node.js environment\n */\nexport const STATUS_IS_NODE_JS = 1;\n/**\n * No SMS hrefs found\n */\nexport const STATUS_NO_SMS_HREFS = 2;\n/**\n * SMS hrefs fixed\n */\nexport const STATUS_SMS_HREFS_FIXED = 3;\n/**\n * Separator is not defined.\n */\nexport const STATUS_SEPARATOR_NOT_DEFINED = 4;\nexport const translateMessages = (code) => new Map([\n    [STATUS_IS_NODE_JS, 'This function is not available in Node.js environment'],\n    [STATUS_NO_SMS_HREFS, 'Anchors with sms: href value doesn\\'t exist'],\n    [STATUS_SMS_HREFS_FIXED, 'SMS href values in anchors on this webpage was updated'],\n    [STATUS_SEPARATOR_NOT_DEFINED, 'Separator is not defined or current platform doesn\\'t support sms: href protocol.'],\n]).get(code) || 'Unknown message';\n/**\n * Separator used in generating SMS hrefs for different platforms.\n */\nexport const SEPARATOR_ANDROID = '?';\nexport const SEPARATOR_IOS = '&';\nexport const SEPARATOR_IOS_7 = ';';\n","import { isAndroid, isIOS } from \"../detectors\";\nimport { SEPARATOR_ANDROID, SEPARATOR_IOS, SEPARATOR_IOS_7, STATUS_IS_NODE_JS, STATUS_NO_SMS_HREFS, STATUS_SEPARATOR_NOT_DEFINED, STATUS_SMS_HREFS_FIXED } from \"../contants\";\nconst replace = (str, searchValue, replaceValue = '') => str?.replace(searchValue, replaceValue);\n/**\n * Class representing a utility for generating and fixing SMS hrefs.\n */\nexport class SmsHref_PIAPI {\n    /**\n     * Separator to be used in SMS hrefs.\n     *\n     * @private\n     * @readonly\n     */\n    _separator;\n    /**\n     * Function to transform phone number value.\n     *\n     * @private\n     * @readonly\n     */\n    _phoneMiddleware;\n    /**\n     * Function to transform message value.\n     *\n     * @private\n     * @readonly\n     */\n    _messageMiddleware;\n    /**\n     *\n     * @private\n     * @readonly\n     */\n    _textEncoder;\n    /**\n     * Constructs an instance of SmsHref_PIAPI.\n     *\n     * @param {TOptions} [opt] - Options for SmsHref_PIAPI.\n     *\n     * @example\n     * const smsHrefInstance = new SmsHref_PIAPI({\n     *     except: [false, true, false], // Example except array\n     *     separator: SEPARATOR_ANDROID, // Example custom separator\n     *     encode: true, // Example encoding enabled\n     *     transform: (value: string) => '+1' + value // Example custom transform function adding country code\n     * });\n     */\n    constructor(opt) {\n        // Determine separator based on provided options or platform\n        this._separator = this._getSeparator(opt?.__separator, opt?.__except);\n        const identityFunction = (value) => value;\n        // Assign middleware functions or use identity function\n        this._phoneMiddleware = opt?.__phoneMiddleware || identityFunction;\n        this._messageMiddleware = opt?.__messageMiddleware || identityFunction;\n        this._textEncoder = opt?.__textEncoder || identityFunction;\n    }\n    /**\n     * Fixes all SMS hrefs within a given context.\n     *\n     * @param {TContext} [context=document] - The context within which to fix SMS hrefs.\n     * @param {boolean} [shouldBypassNodeJs=false] Flag indicating whether to bypass execution in Node.js environment. Default is false.\n     * @returns {Promise<boolean>} A promise resolving to true if any hrefs were fixed, otherwise false.\n     *\n     * @example\n     * await smsHrefInstance.__fixAll(document.body); // Example fixing all SMS hrefs within the document body\n     */\n    async __fixAll(context, shouldBypassNodeJs) {\n        let anchor;\n        let anchors;\n        let value;\n        let errors = [];\n        // Check if running in Node.js\n        if (typeof window === 'undefined' && !shouldBypassNodeJs) {\n            return { code: STATUS_IS_NODE_JS };\n        }\n        // Check if separator is not defined\n        if (!this._separator) {\n            return { code: STATUS_SEPARATOR_NOT_DEFINED };\n        }\n        // Check if no anchor elements with SMS hrefs are found in the given context.\n        if (!(anchors = (context || document).querySelectorAll('a[href^=\"sms:\"]')).length) {\n            return { code: STATUS_NO_SMS_HREFS };\n        }\n        // Iterate over found anchors and fix their hrefs\n        for (anchor of anchors) {\n            if ((value = await this.__fixValue(anchor.href))) {\n                anchor.href = value;\n            }\n            else {\n                errors.push(anchor);\n            }\n        }\n        return { code: STATUS_SMS_HREFS_FIXED, errors };\n    }\n    /**\n     * Fixes a single SMS href value.\n     *\n     * @param {string} value - The SMS href value to fix.\n     * @returns {Promise<TSmsHrefValue|null>} A promise resolving to the fixed SMS href value.\n     *\n     * @example\n     * const fixedHref = await smsHrefInstance.__fixValue('sms:123456789?body=Hello%2C%20world'); // Example fixing a single SMS href\n     * console.log(fixedHref); // Output: 'sms:123456789?body=Hello%2C%20world' (If no transformation or changes applied)\n     */\n    async __fixValue(value) {\n        // Parse the value into phone number and message segments\n        const segments = this._parser(this._textEncoder(replace(value, /&amp;/gi, '&'), 1));\n        // Check if no segments were found\n        if (!segments) {\n            return segments;\n        }\n        // Create a new href based on the parsed segments\n        return await this.__create(segments._phone, segments._message);\n    }\n    /**\n     * Creates a new SMS href based on the provided phone number and message.\n     *\n     * @param {TPhone} phone - The phone number for the SMS.\n     * @param {TMessage} message - The message body for the SMS.\n     * @returns {Promise<TSmsHrefValue | null>} A promise resolving to the generated SMS href value.\n     *\n     * @example\n     * const newHref = await smsHrefInstance.__create('123456789', \"Hello, world!\"); // Example creating a new SMS href\n     * console.log(newHref); // Output: 'sms:123456789?body=Hello%2C%20world%21' (If no transformation or changes applied)\n     */\n    async __create(phone, message) {\n        let value = '';\n        // Add phone number to the href value if provided\n        if ((phone = replace(phone, /[^0-9+A-Z]+/gi))) {\n            value += this._phoneMiddleware(phone);\n        }\n        // Add message body to the href value if provided\n        if (this._separator && (message = this._messageMiddleware(message?.trim()))) {\n            value += this._separator + 'body=' + this._textEncoder(message);\n        }\n        // Construct the final href value\n        return (value ? 'sms:' + value : null);\n    }\n    /**\n     * Parses an SMS href value into phone number and message segments.\n     *\n     * @param {TSmsHrefValue} value - The SMS href value to parse.\n     * @returns {TSegments | null} An object containing phone number and message segments, or null if parsing fails.\n     *\n     * @private\n     * @example\n     * const parsedSegments = this._parser(\"sms:123456789?body=Hello, world!\"); // Example parsing an SMS href value\n     * console.log(parsedSegments); // Output: {_phone: \"123456789\", _message: \"Hello, world!\"}\n     */\n    _parser(value) {\n        // Regular expression to match SMS href format and extract phone number and message segments\n        let [_, _phone, _message] = value.match(/^sms:\\/*([0-9+A-Z]+)?(?:[^0-9A-Z]body=(.+)?)?$/i) || [];\n        // Remove any white spaces from the phone number and message segments\n        _phone = replace(_phone, /\\s+/g);\n        _message = replace(_message, /\\s+/g, ' ')?.trim();\n        // If either phone number and message is not present, return null\n        // Return an object containing phone number and message segments\n        return !_phone && !_message ? null : { _phone, _message };\n    }\n    /**\n     * Determines the separator to be used based on options and platform.\n     *\n     * @param {TSeparator} [customSeparator] - An optional custom separator provided in the options.\n     * @param {boolean[]} [except] - Array of booleans indicating whether to exclude particular options.\n     * @returns {TSeparator | null} The determined separator or null if no separator is applicable.\n     *\n     * @private\n     * @example\n     * const separator = this._getSeparator(SEPARATOR_IOS); // Example getting separator based on custom separator\n     * console.log(separator); // Output: '&'\n     */\n    _getSeparator(customSeparator, except) {\n        let ios;\n        // If any exceptions are included, return null\n        if (except?.includes(true)) {\n            return null;\n        }\n        // If custom separator is provided, use it\n        if (customSeparator) {\n            return customSeparator;\n        }\n        // Determine separator based on platform\n        if (isAndroid()) {\n            return SEPARATOR_ANDROID;\n        }\n        if (!!(ios = isIOS())) {\n            return ios < 8 ? SEPARATOR_IOS_7 : SEPARATOR_IOS;\n        }\n        // If no platform is detected, return null\n        // If no separator is applicable, return null\n        return null;\n    }\n}\n","/////////////////////\n/*************************\n * Run `npm run build` before editing this file\n **************************/\n/////////////////////\n\nimport {\n    SmsHref_PIAPI as SmsHref,\n    STATUS_IS_NODE_JS,\n    STATUS_NO_SMS_HREFS,\n    STATUS_SEPARATOR_NOT_DEFINED,\n    STATUS_SMS_HREFS_FIXED\n} from \"../../lib\";\nimport {translateMessages} from \"../../lib/contants\";\n\n\n(async () => {\n    const smsHref = new SmsHref();\n\n\n////////// Helpers\n\n    const action = (evt, callback) => {\n        evt.preventDefault();\n\n        const form = evt.srcElement;\n        const inputs = getInputs(form);\n        const error = form.querySelector('.text-danger');\n\n        error.textContent = '';\n\n        callback?.(inputs, error);\n    }\n\n    const getInputs = (form) => {\n        const inputs = {}\n        for (let index = 0; index < form.length; index++) {\n            const input = form[index];\n            const id = input.id;\n            if (!!id)\n                inputs[id] = input;\n        }\n        return inputs;\n    }\n\n\n////////////\n// FIX ALL SMS HREF LINKS\n////////////\n\n\n    const resultCode = await smsHref.__fixAll();\n\n    const info = document.querySelector('.info');\n\n    console.log(resultCode)\n\n    switch (resultCode.code) {\n        case STATUS_SMS_HREFS_FIXED:\n            info.classList.add('bg-success');\n            let message = translateMessages(STATUS_SMS_HREFS_FIXED);\n            const err = resultCode.errors;\n            if (err.length) {\n                message += '\\n\\n' + err.map(a => [a.href, a.innerHTML]).join('\\n');\n            }\n            info.textContent = message;\n            console.log(resultCode.errors);\n            break;\n        case STATUS_NO_SMS_HREFS:\n            info.classList.add('bg-warning');\n            info.textContent = translateMessages(STATUS_NO_SMS_HREFS);\n            break;\n        case STATUS_IS_NODE_JS:\n            info.classList.add('bg-danger');\n            info.textContent = translateMessages(STATUS_IS_NODE_JS);\n            break;\n        case STATUS_SEPARATOR_NOT_DEFINED:\n            info.classList.add('bg-danger');\n            info.textContent = translateMessages(STATUS_SEPARATOR_NOT_DEFINED);\n    }\n\n////////////\n// CREATE SMS HREF LINK\n////////////\n\n    const create = document.querySelector('.create');\n    create.addEventListener('submit', (evt) => {\n        action(evt, async (inputs, error) => {\n\n            const smsValue = await smsHref.__create(inputs.phone.value, inputs.message.value);\n\n            if (smsValue) {\n                inputs.output.value = smsValue\n            } else {\n                error.textContent = 'sms value error';\n            }\n\n        });\n    });\n\n////////////\n// UPDATE SMS HREF LINK TEXT\n////////////\n\n    const update = document.querySelector('.update');\n    update.addEventListener('submit', (evt) => {\n        action(evt, async (inputs, error) => {\n\n            const fixedValue = await smsHref.__fixValue(inputs['sms-text'].value);\n\n            if (fixedValue) {\n                inputs.fixed.value = fixedValue;\n            } else {\n                error.textContent = 'Fixed value error';\n            }\n\n        });\n    });\n\n\n})()\n"],"names":["UA","navigator","userAgent","isIOS","value","test","isNaN","match","isAndroid","groups","translateMessages","code","Map","get","replace","str","searchValue","replaceValue","_separator","_phoneMiddleware","_messageMiddleware","_textEncoder","constructor","opt","this","_getSeparator","__separator","__except","identityFunction","__phoneMiddleware","__messageMiddleware","__textEncoder","async","context","shouldBypassNodeJs","anchor","anchors","errors","window","document","querySelectorAll","length","__fixValue","href","push","segments","_parser","__create","_phone","_message","phone","message","trim","_","customSeparator","except","ios","includes","smsHref","action","evt","callback","preventDefault","form","srcElement","inputs","getInputs","error","querySelector","textContent","index","input","id","resultCode","__fixAll","info","console","log","classList","add","err","map","a","innerHTML","join","addEventListener","smsValue","output","fixedValue","fixed"],"sourceRoot":""}