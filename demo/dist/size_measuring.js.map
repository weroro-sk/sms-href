{"version":3,"file":"size_measuring.js","mappings":"mBACA,MAAMA,EAAKC,UAAUC,UAaRC,EAAQ,KACjB,IAAIC,EAEJ,MAAI,iCAAiCC,KAAKL,IAE9B,EAGLM,MAAOF,GAASJ,EAAGO,MAAM,2BAA2B,IAAO,EAAIH,CAAK,EAalEI,EAAY,KACrB,IAAIJ,EAEAK,EAAST,EAAGO,MAAM,4BAEtB,OAAKE,IAAS,GAIPH,MAAOF,GAASK,IAAS,KAAQ,EAAIL,EAHjC,CAGsC,EC1C/CM,EAAU,CAACC,EAAKC,EAAaC,EAAe,KAAOF,GAAKD,QAAQE,EAAaC,GCInF,IDAO,MAOHC,EAOAC,EAOAC,EAMAC,EAcAC,YAAYC,GAERC,KAAKN,EAAaM,KAAKC,EAAcF,GAAKG,EAAaH,GAAKI,GAC5D,MAAMC,EAAoBpB,GAAUA,EAEpCgB,KAAKL,EAAmBI,GAAKM,GAAqBD,EAClDJ,KAAKJ,EAAqBG,GAAKO,GAAuBF,EACtDJ,KAAKH,EAAeE,GAAKQ,GAAiBH,CAC9C,CAWAI,QAAeC,EAASC,GACpB,IAAIC,EACAC,EACA5B,EACA6B,EAAS,GAEb,GAAsB,oBAAXC,SAA2BJ,EAClC,MAAO,CAAEK,KEtEY,GFyEzB,IAAKf,KAAKN,EACN,MAAO,CAAEqB,KE9DuB,GFiEpC,KAAMH,GAAWH,GAAWO,UAAUC,iBAAiB,oBAAoBC,OACvE,MAAO,CAAEH,KE1Ec,GF6E3B,IAAKJ,KAAUC,GACN5B,QAAcgB,KAAKmB,EAAWR,EAAOS,OACtCT,EAAOS,KAAOpC,EAGd6B,EAAOQ,KAAKV,GAGpB,MAAO,CAAEI,KEjFqB,EFiFSF,SAC3C,CAWAL,QAAiBxB,GAEb,MAAMsC,EAAWtB,KAAKuB,EAAQvB,KAAKH,EAAaP,EAAQN,EAAO,UAAW,KAAM,IAEhF,OAAKsC,QAIQtB,KAAKwB,EAASF,EAASG,EAAQH,EAASI,GAH1CJ,CAIf,CAYAd,QAAemB,EAAOC,GAClB,IAAI5C,EAAQ,GAUZ,OARK2C,EAAQrC,EAAQqC,EAAO,oBACxB3C,GAASgB,KAAKL,EAAiBgC,IAG/B3B,KAAKN,IAAekC,EAAU5B,KAAKJ,EAAmBgC,GAASC,WAC/D7C,GAASgB,KAAKN,EAAa,QAAUM,KAAKH,EAAa+B,IAGnD5C,EAAQ,OAASA,EAAQ,IACrC,CAYAuC,EAAQvC,GAEJ,IAAK8C,EAAGL,EAAQC,GAAY1C,EAAMG,MAAM,oDAAsD,GAM9F,OAJAsC,EAASnC,EAAQmC,EAAQ,QACzBC,EAAWpC,EAAQoC,EAAU,OAAQ,MAAMG,OAGnCJ,GAAWC,EAAkB,CAAED,IAAQC,KAAjB,IAClC,CAaAzB,EAAc8B,EAAiBC,GAC3B,IAAIC,EAEJ,OAAID,GAAQE,UAAS,GACV,KAGPH,IAIA3C,IE7JqB,KFgKlB6C,EAAMlD,KACFkD,EAAM,EE/JM,IADF,IFoKd,KACX,E","sources":["webpack://sms-href/./lib/detectors.js","webpack://sms-href/./lib/classes/sms-href-piapi.js","webpack://sms-href/./demo/src/size_measuring.js","webpack://sms-href/./lib/contants.js"],"sourcesContent":["/////////////////////\nconst UA = navigator.userAgent;\n/////////////////////\n/**\n * Checks if the user agent corresponds to an iOS device and returns its version.\n *\n * @returns {number} Returns the iOS version.\n *                   - `version` - If is iOS, and version is provided return major iOS version.\n *                   - `-1` - If is iOS, and version is not provided.\n *                   - `0` - Returns 0 if the user agent does not match iOS.\n * @example\n * // Returns 14 if the user agent matches \"CPU OS 14_0\"\n * const iOSVersion = isIOS();\n */\nexport const isIOS = () => {\n    let value;\n    // Check if the user agent matches the pattern of iOS devices\n    if (/CPU like.*AppleWebKit.*Mobile/i.test(UA)) {\n        // Return -1 if the user agent corresponds to a non-iOS device\n        return -1;\n    }\n    // Extract iOS version number from the user agent string\n    return isNaN((value = +UA.match(/CPU.*OS ([0-9]{1,5})/i)?.[1])) ? 0 : value;\n};\n/**\n * Checks if the user agent corresponds to an Android device and returns its version.\n *\n * @returns {number} Returns the Android version.\n *                   - `version` - If is Android, and version is provided return major Android version.\n *                   - `-1` - If is Android, and version is not provided.\n *                   - `0` - Returns 0 if the user agent does not match \"Android\".\n * @example\n * // Returns 10 if the user agent matches \"Android 10\"\n * const androidVersion = isAndroid();\n */\nexport const isAndroid = () => {\n    let value;\n    // Extract groups from the user agent string matching \"Android\" followed by version number\n    let groups = UA.match(/(Android) ([0-9]{1,5})?/i);\n    // If there are no groups or the first group is not present, return 0\n    if (!groups?.[1]) {\n        return 0;\n    }\n    // If the version number is present, convert it to a number, else return -1\n    return isNaN((value = +groups?.[2])) ? -1 : value;\n};\n/**\n * Checks if the device is an iPhone.\n *\n * @returns {boolean} True if the device is an iPhone, otherwise false.\n * @example\n * // Returns true if the device is an iPhone\n * const isDeviceIPhone = isIPhone();\n */\nexport const isIPhone = () => \n// Check if the device is iOS and not an iPod or iPad\n!!isIOS() && !isIPod() && !isIPad();\n/**\n * This is an alias for {@link isIPhone} function.\n *\n * Checks if the device is an iOS mobile (iPhone).\n */\nexport const isAppleMobile = isIPhone;\n/**\n * Checks if the device is an iPod.\n *\n * @returns {boolean} True if the device is an iPod, otherwise false.\n * @example\n * // Returns true if the device is an iPod\n * const isIPodDevice = isIPod();\n */\nexport const isIPod = () => \n// Check if the device is iOS and if the user agent contains \"ipod\"\n!!isIOS() && /ipod/i.test(UA);\n/**\n * Checks if the device is an iPad.\n *\n * @returns {boolean} True if the device is an iPad, otherwise false.\n * @example\n * // Returns true if the device is an iPad\n * const isIPadDevice = isIPad();\n */\nexport const isIPad = () => \n// Check if the device is iOS and if the user agent contains \"ipad\"\n!!isIOS() && /ipad/i.test(UA);\n/**\n * This is an alias for {@link isIPad} function.\n *\n * Checks if the device is an iOS tablet (iPad).\n */\nexport const isIosTablet = isIPad;\n/**\n * This is an alias for {@link isIPad} function.\n *\n * Checks if the device is an Apple tablet (iPad).\n */\nexport const isAppleTablet = isIPad;\n/**\n * Checks if the device is an Android mobile device.\n * @returns {boolean} True if the device is an Android mobile device, otherwise false.\n * @example\n * // Returns true if the device is an Android mobile device\n * const isAndroidMobileDevice = isAndroidMobile();\n */\nexport const isAndroidMobile = () => \n// Check if the device is Android and if the user agent contains \"Mobile\"\n!!isAndroid() && /Mobile/i.test(UA);\n/**\n * Checks if the device is an Android tablet.\n *\n * @returns {boolean} True if the device is an Android tablet, otherwise false.\n * @example\n * // Returns true if the device is an Android tablet\n * const isDeviceAndroidTablet = isAndroidTablet();\n */\nexport const isAndroidTablet = () => \n// Check if the device is Android and if the user agent does not contain \"Mobile\"\n!!isAndroid() && !isAndroidMobile();\n/**\n * Checks if the device is a tablet (either Android tablet or iPad).\n *\n * @returns {boolean} True if the device is a tablet, otherwise false.\n * @example\n * // Returns true if the device is a tablet\n * const isDeviceTablet = isTablet();\n */\nexport const isTablet = () => isIPad() || isAndroidTablet();\n/**\n * Checks if the device is a mobile device (either iPhone or Android mobile).\n *\n * @returns {boolean} True if the device is a mobile device, otherwise false.\n * @example\n * // Returns true if the device is a mobile device\n * const isDeviceMobile = isMobile();\n */\nexport const isMobile = () => isIPhone() || isAndroidMobile();\n/**\n * Checks if the user agent corresponds to a Facebook browser.\n *\n * @returns {boolean} True if the user agent indicates a Facebook browser, otherwise false.\n * @example\n * // Returns true if the user agent indicates a Facebook browser\n * const isFacebookBrowser = isFacebook();\n */\nexport const isFacebook = () => \n// Test if the user agent contains \"fban\" or \"fbav\"\n/fba[nv]/i.test(UA);\n/**\n * Checks if the user agent corresponds to Instagram.\n *\n * @returns {boolean} True if the user agent indicates Instagram, otherwise false.\n * @example\n * // Returns true if the user agent indicates Instagram\n * const isInstagram = isInstagram();\n */\nexport const isInstagram = () => \n// Test if the user agent contains \"instagram\" (case-insensitive)\n/instagram/i.test(UA);\n/**\n * Checks if the user agent string contains \"LinkedIn\".\n *\n * @returns {boolean} Returns true if the user agent string contains \"LinkedIn\", otherwise false.\n * @example\n * // Returns true if UA contains \"LinkedIn\"\n * const result = isLinkedin();\n *\n * @see https://explore.whatismybrowser.com/useragents/explore/software_name/linkedin-app/\n */\nexport const isLinkedin = () => \n// Test if the user agent contains \"LinkedIn\" (case-insensitive)\n/linkedin/i.test(UA);\n","import { isAndroid, isIOS } from \"../detectors\";\nimport { SEPARATOR_ANDROID, SEPARATOR_IOS, SEPARATOR_IOS_7, STATUS_IS_NODE_JS, STATUS_NO_SMS_HREFS, STATUS_SEPARATOR_NOT_DEFINED, STATUS_SMS_HREFS_FIXED } from \"../contants\";\nconst replace = (str, searchValue, replaceValue = '') => str?.replace(searchValue, replaceValue);\n/**\n * Class representing a utility for generating and fixing SMS hrefs.\n */\nexport class SmsHref_PIAPI {\n    /**\n     * Separator to be used in SMS hrefs.\n     *\n     * @private\n     * @readonly\n     */\n    _separator;\n    /**\n     * Function to transform phone number value.\n     *\n     * @private\n     * @readonly\n     */\n    _phoneMiddleware;\n    /**\n     * Function to transform message value.\n     *\n     * @private\n     * @readonly\n     */\n    _messageMiddleware;\n    /**\n     *\n     * @private\n     * @readonly\n     */\n    _textEncoder;\n    /**\n     * Constructs an instance of SmsHref_PIAPI.\n     *\n     * @param {TOptions} [opt] - Options for SmsHref_PIAPI.\n     *\n     * @example\n     * const smsHrefInstance = new SmsHref_PIAPI({\n     *     except: [false, true, false], // Example except array\n     *     separator: SEPARATOR_ANDROID, // Example custom separator\n     *     encode: true, // Example encoding enabled\n     *     transform: (value: string) => '+1' + value // Example custom transform function adding country code\n     * });\n     */\n    constructor(opt) {\n        // Determine separator based on provided options or platform\n        this._separator = this._getSeparator(opt?.__separator, opt?.__except);\n        const identityFunction = (value) => value;\n        // Assign middleware functions or use identity function\n        this._phoneMiddleware = opt?.__phoneMiddleware || identityFunction;\n        this._messageMiddleware = opt?.__messageMiddleware || identityFunction;\n        this._textEncoder = opt?.__textEncoder || identityFunction;\n    }\n    /**\n     * Fixes all SMS hrefs within a given context.\n     *\n     * @param {TContext} [context=document] - The context within which to fix SMS hrefs.\n     * @param {boolean} [shouldBypassNodeJs=false] Flag indicating whether to bypass execution in Node.js environment. Default is false.\n     * @returns {Promise<boolean>} A promise resolving to true if any hrefs were fixed, otherwise false.\n     *\n     * @example\n     * await smsHrefInstance.__fixAll(document.body); // Example fixing all SMS hrefs within the document body\n     */\n    async __fixAll(context, shouldBypassNodeJs) {\n        let anchor;\n        let anchors;\n        let value;\n        let errors = [];\n        // Check if running in Node.js\n        if (typeof window === 'undefined' && !shouldBypassNodeJs) {\n            return { code: STATUS_IS_NODE_JS };\n        }\n        // Check if separator is not defined\n        if (!this._separator) {\n            return { code: STATUS_SEPARATOR_NOT_DEFINED };\n        }\n        // Check if no anchor elements with SMS hrefs are found in the given context.\n        if (!(anchors = (context || document).querySelectorAll('a[href^=\"sms:\"]')).length) {\n            return { code: STATUS_NO_SMS_HREFS };\n        }\n        // Iterate over found anchors and fix their hrefs\n        for (anchor of anchors) {\n            if ((value = await this.__fixValue(anchor.href))) {\n                anchor.href = value;\n            }\n            else {\n                errors.push(anchor);\n            }\n        }\n        return { code: STATUS_SMS_HREFS_FIXED, errors };\n    }\n    /**\n     * Fixes a single SMS href value.\n     *\n     * @param {string} value - The SMS href value to fix.\n     * @returns {Promise<TSmsHrefValue|null>} A promise resolving to the fixed SMS href value.\n     *\n     * @example\n     * const fixedHref = await smsHrefInstance.__fixValue('sms:123456789?body=Hello%2C%20world'); // Example fixing a single SMS href\n     * console.log(fixedHref); // Output: 'sms:123456789?body=Hello%2C%20world' (If no transformation or changes applied)\n     */\n    async __fixValue(value) {\n        // Parse the value into phone number and message segments\n        const segments = this._parser(this._textEncoder(replace(value, /&amp;/gi, '&'), 1));\n        // Check if no segments were found\n        if (!segments) {\n            return segments;\n        }\n        // Create a new href based on the parsed segments\n        return await this.__create(segments._phone, segments._message);\n    }\n    /**\n     * Creates a new SMS href based on the provided phone number and message.\n     *\n     * @param {TPhone} phone - The phone number for the SMS.\n     * @param {TMessage} message - The message body for the SMS.\n     * @returns {Promise<TSmsHrefValue | null>} A promise resolving to the generated SMS href value.\n     *\n     * @example\n     * const newHref = await smsHrefInstance.__create('123456789', \"Hello, world!\"); // Example creating a new SMS href\n     * console.log(newHref); // Output: 'sms:123456789?body=Hello%2C%20world%21' (If no transformation or changes applied)\n     */\n    async __create(phone, message) {\n        let value = '';\n        // Add phone number to the href value if provided\n        if ((phone = replace(phone, /[^0-9+A-Z]+/gi))) {\n            value += this._phoneMiddleware(phone);\n        }\n        // Add message body to the href value if provided\n        if (this._separator && (message = this._messageMiddleware(message?.trim()))) {\n            value += this._separator + 'body=' + this._textEncoder(message);\n        }\n        // Construct the final href value\n        return (value ? 'sms:' + value : null);\n    }\n    /**\n     * Parses an SMS href value into phone number and message segments.\n     *\n     * @param {TSmsHrefValue} value - The SMS href value to parse.\n     * @returns {TSegments | null} An object containing phone number and message segments, or null if parsing fails.\n     *\n     * @private\n     * @example\n     * const parsedSegments = this._parser(\"sms:123456789?body=Hello, world!\"); // Example parsing an SMS href value\n     * console.log(parsedSegments); // Output: {_phone: \"123456789\", _message: \"Hello, world!\"}\n     */\n    _parser(value) {\n        // Regular expression to match SMS href format and extract phone number and message segments\n        let [_, _phone, _message] = value.match(/^sms:\\/*([0-9+A-Z]+)?(?:[^0-9A-Z]body=(.+)?)?$/i) || [];\n        // Remove any white spaces from the phone number and message segments\n        _phone = replace(_phone, /\\s+/g);\n        _message = replace(_message, /\\s+/g, ' ')?.trim();\n        // If either phone number and message is not present, return null\n        // Return an object containing phone number and message segments\n        return !_phone && !_message ? null : { _phone, _message };\n    }\n    /**\n     * Determines the separator to be used based on options and platform.\n     *\n     * @param {TSeparator} [customSeparator] - An optional custom separator provided in the options.\n     * @param {boolean[]} [except] - Array of booleans indicating whether to exclude particular options.\n     * @returns {TSeparator | null} The determined separator or null if no separator is applicable.\n     *\n     * @private\n     * @example\n     * const separator = this._getSeparator(SEPARATOR_IOS); // Example getting separator based on custom separator\n     * console.log(separator); // Output: '&'\n     */\n    _getSeparator(customSeparator, except) {\n        let ios;\n        // If any exceptions are included, return null\n        if (except?.includes(true)) {\n            return null;\n        }\n        // If custom separator is provided, use it\n        if (customSeparator) {\n            return customSeparator;\n        }\n        // Determine separator based on platform\n        if (isAndroid()) {\n            return SEPARATOR_ANDROID;\n        }\n        if (!!(ios = isIOS())) {\n            return ios < 8 ? SEPARATOR_IOS_7 : SEPARATOR_IOS;\n        }\n        // If no platform is detected, return null\n        // If no separator is applicable, return null\n        return null;\n    }\n}\n","////////////\n// DO NOT EDIT THIS FILE\n////////////\n// This file is only for minimal build size measuring\nimport {SmsHref_PIAPI as SmsHref} from \"../../lib\";\n\nnew SmsHref();\n","/**\n * This function is not available in Node.js environment\n */\nexport const STATUS_IS_NODE_JS = 1;\n/**\n * No SMS hrefs found\n */\nexport const STATUS_NO_SMS_HREFS = 2;\n/**\n * SMS hrefs fixed\n */\nexport const STATUS_SMS_HREFS_FIXED = 3;\n/**\n * Separator is not defined.\n */\nexport const STATUS_SEPARATOR_NOT_DEFINED = 4;\nexport const translateMessages = (code) => new Map([\n    [STATUS_IS_NODE_JS, 'This function is not available in Node.js environment'],\n    [STATUS_NO_SMS_HREFS, 'Anchors with sms: href value doesn\\'t exist'],\n    [STATUS_SMS_HREFS_FIXED, 'SMS href values in anchors on this webpage was updated'],\n    [STATUS_SEPARATOR_NOT_DEFINED, 'Separator is not defined or current platform doesn\\'t support sms: href protocol.'],\n]).get(code) || 'Unknown message';\n/**\n * Separator used in generating SMS hrefs for different platforms.\n */\nexport const SEPARATOR_ANDROID = '?';\nexport const SEPARATOR_IOS = '&';\nexport const SEPARATOR_IOS_7 = ';';\n"],"names":["UA","navigator","userAgent","isIOS","value","test","isNaN","match","isAndroid","groups","replace","str","searchValue","replaceValue","_separator","_phoneMiddleware","_messageMiddleware","_textEncoder","constructor","opt","this","_getSeparator","__separator","__except","identityFunction","__phoneMiddleware","__messageMiddleware","__textEncoder","async","context","shouldBypassNodeJs","anchor","anchors","errors","window","code","document","querySelectorAll","length","__fixValue","href","push","segments","_parser","__create","_phone","_message","phone","message","trim","_","customSeparator","except","ios","includes"],"sourceRoot":""}